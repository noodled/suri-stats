#!/usr/bin/env python
# Copyright (C) 2012 Eric Leblond <eric@regit.org>
#
# You can copy, redistribute or modify this Program under the terms of
# the GNU General Public License version 3 as published by the Free
# Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# version 3 along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.

from suristats import *
import argparse
import os
import sys
import sqlite3

def start_ipython_pylab():
    # Try running this code both at the command line and from inside IPython (with
    # %run example-embed.py)
    from IPython.config.loader import Config
    try:
        get_ipython
    except NameError:
        nested = 0
        cfg = Config()
        prompt_config = cfg.PromptManager
        prompt_config.in_template = 'In <\\#>: '
        prompt_config.in2_template = '   .\\D.: '
        prompt_config.out_template = 'Out<\\#>: '
    else:
        print("Running nested copies of IPython.")
        print("The prompts for the nested copy have been modified")
        cfg = Config()
        nested = 1

    from IPython.frontend.terminal.embed import InteractiveShellEmbed
    ipshell = InteractiveShellEmbed(config=cfg,
                           banner1 = 'Dropping into IPython',
                           exit_msg = 'Leaving Interpreter, back to program.')
    ipshell.enable_pylab()
    return ipshell

def init_sqlite(db_file):
    if os.path.isfile(db_file):
        sys.stderr.write("Will not overwrite existing file\n")
        sys.exit(1)
    conn = sqlite3.connect(db_file)
    conn.execute('''CREATE TABLE counters
             (timestamp float, run_id text, host_id text, version text, counter text, min real, mean real, max real, std real)''')
    conn.commit()
    conn.close()

def store_run_sqlite(ST, counters_list, db_file, timestamp, run_id, host_id, version):
    if not os.path.isfile(db_file):
        sys.stderr.write("'%s' is not a file\n" % (db_file))
        sys.exit(1)
    res_mean = ST.mean(counters_list, speed=args.speed)
    res_max = ST.max(counters_list, speed=args.speed)
    res_min = ST.min(counters_list, speed=args.speed)
    res_std = ST.std(counters_list, speed=args.speed)
    vcounters = []
    for key in res_mean.keys():
        vcounters.append((timestamp, run_id, host_id, version, key,
            res_min[key], res_mean[key], res_max[key], res_std[key]))
    conn = sqlite3.connect(db_file)
    conn.executemany("INSERT INTO counters VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)", vcounters)
    conn.commit()
    conn.close()

parser = argparse.ArgumentParser(prog='suri-stats', description='Statistic ang graphing tools for Suricata stats.log')
parser.add_argument('-c', '--counters', default=None, help='Counters to work on')
parser.add_argument('-s', '--stats', action='store_const', const=True, default=False, help='Output stats on file')
parser.add_argument('-p', '--plot', action='store_const', const=True, default=False, help='Plot specified counters')
parser.add_argument('-o', '--output', dest='output_file', default='out.png', help='Output file for graph')
parser.add_argument('-S', '--speed', action='store_const', const=True, default=False, help='Use computed speed not counter')
parser.add_argument('-i', '--identifier', default='Run', help='Identifier of the run')
parser.add_argument('-H', '--host', default='localhost', help='Identifier of host')
parser.add_argument('-V', '--version', default='HEAD', help='Identifier of version')
parser.add_argument('-I', '--initdb', default=None, help='Create the DB file specified as argument')
parser.add_argument('-U', '--updatedb', default=None, help='Update the DB file specified as argument')
parser.add_argument('-v', '--verbose', action='store_const', const=True, help='verbose output', default=False)
parser.add_argument('file', metavar='file', nargs='*', help='stats.log file to parse', default=None)

args = parser.parse_args()

if args.initdb:
    init_sqlite(args.initdb)
    sys.exit(0)

ST = Stats(args.identifier)
if args.verbose:
    print "Created ST object for run '%s'" % (args.identifier)

if len(args.file) > 1:
    sys.stderr.write("Only one file supported for now\n")
    sys.exit(1)
elif len(args.file) == 1:
    [stats_file] = args.file
    if os.path.isfile(stats_file):
        if args.verbose:
            print "Loading stats.log file '%s'" % (stats_file)
        ST.load_file(stats_file)
    else:
        sys.stderr.write("'%s' is not a valid file, leaving\n" % (stats_file))
        sys.exit(1)
else:
    if args.verbose:
        print "No file loaded, you need to call load_file() on ST"

# Do we have an action asked
if args.stats:
    if len(args.file) == 0:
        sys.stderr.write("You need to specify a file\n")
        sys.exit(1)
    if args.counters:
        counters_list = args.counters.split(",")
        res_mean = ST.mean(counters_list, speed=args.speed)
        res_max = ST.max(counters_list, speed=args.speed)
        res_min = ST.min(counters_list, speed=args.speed)
        res_std = ST.std(counters_list, speed=args.speed)
    else:
        res_mean = ST.mean(speed=args.speed)
        res_max = ST.max(speed=args.speed)
        res_min = ST.min(speed=args.speed)
        res_std = ST.std(speed=args.speed)
    if args.verbose:
        print "Key:Min:Mean:Max:Std"
    for key in sorted(res_min):
        print "%s:%f:%f:%f:%f" % (key, res_min[key], res_mean[key], res_max[key], res_std[key])
elif args.plot:
    if len(args.file) == 0:
        sys.stderr.write("You need to specify a file\n")
        sys.exit(1)
    if args.counters:
        counters_list = args.counters.split(",")
        for counter in counters_list:
            ST.plot(counter, speed=args.speed)
        savefig(args.output_file)
    else:
        sys.stderr.write("Nothing to plot, please specify some counters\n")
        sys.exit(1)
elif args.updatedb:
    from time import time
    if len(args.file) == 0:
        sys.stderr.write("You need to specify a file\n")
        sys.exit(1)
    if args.counters:
        counters_list = args.counters.split(",")
    else:
        counters_list = None
    store_run_sqlite(ST, counters_list, args.updatedb, time(), args.identifier, args.host, args.version)
else:
    ipshell = start_ipython_pylab()
    ipshell('Starting interactive session')
